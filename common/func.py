# Standard imports + DICOM
import numpy as np
import pandas as pd
import os
import math
import pydicom 
import matplotlib.pyplot as plt
from glob import glob
from pathlib import Path
from PIL import Image
import json
import imageio
import torch

# CIL framework
from cil.framework import ImageData, ImageGeometry
from cil.framework import AcquisitionGeometry, AcquisitionData
from cil.framework import BlockDataContainer

from cil.optimisation.algorithms import CGLS, SIRT, GD, FISTA, PDHG
from cil.optimisation.operators import BlockOperator, GradientOperator, \
                                       IdentityOperator, \
                                       GradientOperator, FiniteDifferenceOperator
from cil.optimisation.functions import IndicatorBox, MixedL21Norm, \
                                       L2NormSquared, \
                                       BlockFunction, L1Norm, LeastSquares, \
                                       OperatorCompositionFunction, \
                                       TotalVariation, \
                                       ZeroFunction

# CIL Processors
from cil.processors import CentreOfRotationCorrector, Slicer

from cil.utilities.display import show2D

# Plugins
from cil.plugins.astra.processors import FBP, AstraBackProjector3D
from cil.plugins.astra.operators import ProjectionOperator
from cil.plugins import TomoPhantom
from tqdm import tqdm

    
# Filter all files with incorrect orientation
def select_orientation(slice_file):
    
    orientation = slice_file[0x0020, 0x0037].value
    
    if orientation[0] == -1 or orientation[4] == -1:
        return False
    
    else:
        return True
    
# Filter all files by z-axis coordinate
def select_z(slice_file, z_coord, error_bound):
    z_axis_val = slice_file[0x0020, 0x0032].value[2]
    if z_axis_val > (z_coord + error_bound) or z_axis_val < (z_coord - error_bound):
        return False
    else:
        return True
    
# Stores the filtered list of files generated by "filter_files"
# into a "settings.json" file
def store_params(param_dict, filepath=os.path.join(os.getcwd(), "settings.json")):
    with open(filepath, "w") as f:
        return json.dump(param_dict, f)
    
    
# Load the "settings.json" file as a dict
def load_params(filepath):
    with open(filepath, "r") as f:
        return json.load(f)
    
    
# Splits the patient into train and test sets
def train_test_split(filepaths, prop_train=0.8, random_seed=None):
    
    rng = np.random.default_rng(seed=random_seed)
    rng.shuffle(filepaths)

    prop_ind = round(len(filepaths)*prop_train)
    train_list = filepaths[:prop_ind]
    test_list = filepaths[prop_ind:]

    return train_list, test_list

'''
Function loads all valid .dcm files in a directory, 
returns filepaths of CT images only.

Additionally, allows to pass functions that will constitute
additional filtering conditionals.

Functions must be of the form:  

  func(pydicom_file) -> bool
  
Must return False for the file to be excluded
'''
        
def filter_flies(directory = os.getcwd(), *args):

    out_dict = {}

    # Load all files present in the directory
    file_dirs = glob(f"{directory}/**/*.dcm", recursive=True)

    filtered_dir_list = []
    diam_list = []
    pix_spac = []
    print("Initial File Selection:")
    for slice_filepath in tqdm(file_dirs):
        slice_file = pydicom.dcmread(slice_filepath) # Load image with pydicom
        
        if slice_file[0x0008,0x0060].value == "CT": # Load CT images only

            # Filters each value through functions
            check = True
            for arg in args:
                check = check and arg(slice_file) 
            if check == False:
                continue
            
            diam_list.append(slice_file[0x0018, 0x1100].value)
            pix_spac.append(slice_file[0x0028, 0x0030].value)
            filtered_dir_list.append(slice_filepath)
    
    out_dict["filepaths"] = filtered_dir_list
    out_dict["diam_lowq"] = np.quantile(diam_list, 0.25)
    out_dict["diam_highq"] = np.quantile(diam_list, 0.75)
    out_dict["pix_space"] = np.mean(pix_spac, axis = 0).tolist()

    return out_dict

# Function to normalize array to min_val -> max_val
def normalization(array, min_val=0, max_val=1):
    norm_array = (max_val-min_val)/(array.max() - array.min())*(array - array.min())
    return norm_array

# Rescale image to "dims" pixels
def resize(array, dims):
    im_array = Image.fromarray(array)
    im_resized = im_array.resize(dims)
    img = np.array(im_resized)
    return img

def zoom(array, diameter, diameter_bounds):
    array_shape = array.shape
    diameter_bounds = np.sort(diameter_bounds)

    if diameter < diameter_bounds[0]:
        ratio_down = diameter_bounds[0]/diameter
        new_size = np.round(ratio_down*np.array(array_shape)).astype('int16')

        offset_x = int(new_size[0] - array_shape[0])
        if offset_x % 2 == 0:
            offset_x = round(offset_x/2)
            opp_offset_x = offset_x
        else:
            offset_x = round((offset_x - 1)/2)
            opp_offset_x = offset_x + 1

        offset_y = int(new_size[1] - array_shape[1])
        if offset_y % 2 == 0:
            offset_y = round(offset_y/2)
            opp_offset_y = offset_y
        else:
            offset_y = round((offset_y - 1)/2)
            opp_offset_y = offset_y + 1

        temp_arr = np.zeros(new_size)
        temp_arr[offset_x:temp_arr.shape[0]-opp_offset_x, offset_y:temp_arr.shape[1]-opp_offset_y] = array[:, :]


    elif diameter > diameter_bounds[1]:
        ratio_up = diameter_bounds[1]/diameter
        new_size = np.round(ratio_up*np.array(array_shape)).astype('int16')

        offset_x = int(array_shape[0] - new_size[0])
        if offset_x % 2 == 0:
            offset_x = round(offset_x/2)
            opp_offset_x = offset_x
        else:
            offset_x = round((offset_x - 1)/2)
            opp_offset_x = offset_x + 1

        offset_y = int(array_shape[1] - new_size[1])
        if offset_y % 2 == 0:
            offset_y = round(offset_y/2)
            opp_offset_y = offset_y
        else:
            offset_y = round((offset_y - 1)/2)
            opp_offset_y = offset_y + 1

        temp_arr = np.zeros(new_size)
        temp_arr[:, :] = array[offset_x:array_shape[0]-opp_offset_x, offset_y:array_shape[1]-opp_offset_y]


    else:
        temp_arr = array

    return temp_arr

def init_sampler(fm_path, chol_path, dims=(128, 128)):

    z = np.random.normal(0, 1, size=(dims[0]*dims[1]))

    sample = fm_path.T + chol_path @ z.T
    sample = sample.T

    return sample